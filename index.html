<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Fast-SCNN ONNX Navigation</title>
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <style>
    canvas {
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <h2>Fast-SCNN ONNX Navigation</h2>
  <video id="webcam" width="640" height="480" autoplay muted></video>
  <canvas id="canvas" width="640" height="480"></canvas>

  <script>
    const classes = [
      "background",
      "Block 2",
      "Block 3",
      "Open Audi",
      "Open Audi Stage",
      "Road",
      "Students Square"
    ];

    // Load ONNX model
    let session;
    async function loadModel() {
      session = await ort.InferenceSession.create('fastscnn_campus.onnx');
      console.log("âœ… ONNX model loaded");
    }

    async function init() {
      await loadModel();

      const video = document.getElementById('webcam');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Request webcam access
      const stream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = stream;

      video.addEventListener('play', () => {
        const width = video.videoWidth;
        const height = video.videoHeight;

        canvas.width = width;
        canvas.height = height;

        async function render() {
          ctx.drawImage(video, 0, 0, width, height);
          let frame = ctx.getImageData(0, 0, width, height);
          let data = frame.data;

          // Preprocess: HWC -> CHW, normalize
          let input = new Float32Array(3 * 256 * 256);
          const scaleX = width / 256;
          const scaleY = height / 256;

          for (let y = 0; y < 256; y++) {
            for (let x = 0; x < 256; x++) {
              const srcX = Math.floor(x * scaleX);
              const srcY = Math.floor(y * scaleY);
              const idxSrc = (srcY * width + srcX) * 4;
              const idxDst = y * 256 + x;
              input[idxDst] = data[idxSrc] / 255.0;         // R
              input[idxDst + 256*256] = data[idxSrc + 1] / 255.0; // G
              input[idxDst + 2*256*256] = data[idxSrc + 2] / 255.0; // B
            }
          }

          const tensor = new ort.Tensor('float32', input, [1, 3, 256, 256]);
          const output = await session.run({ input: tensor });
          let pred = output.output.data; // flattened

          // Reshape pred to [num_classes, H, W]
          const H = 256, W = 256, C = classes.length;
          let pred2d = new Array(H).fill(0).map(() => new Array(W).fill(0));
          for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
              let maxVal = -Infinity;
              let maxClass = 0;
              for (let c = 0; c < C; c++) {
                const v = pred[c*H*W + y*W + x];
                if (v > maxVal) { maxVal = v; maxClass = c; }
              }
              pred2d[y][x] = maxClass;
            }
          }

          // Find largest area for each class and overlay text
          for (let c = 1; c < C; c++) { // skip background
            // Find all pixels of class c
            let points = [];
            for (let y = 0; y < H; y++) {
              for (let x = 0; x < W; x++) {
                if (pred2d[y][x] === c) points.push([x, y]);
              }
            }

            if (points.length === 0) continue;

            // Compute center of largest cluster approx
            let sumX = 0, sumY = 0;
            for (let p of points) { sumX += p[0]; sumY += p[1]; }
            let cx = Math.floor(sumX / points.length * scaleX);
            let cy = Math.floor(sumY / points.length * scaleY);

            ctx.fillStyle = 'red';
            ctx.font = '20px Arial';
            ctx.fillText(classes[c], cx - 20, cy);
          }

          requestAnimationFrame(render);
        }

        render();
      });
    }

    init();
  </script>
</body>
</html>
